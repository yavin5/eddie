import * as path from 'path';
import { readdirSync } from 'fs';
import * as ts from 'typescript';

/**
 * This PluginLoader was mostly generated by GPT-4o using the prompt:
 * I want to write a plugin loader class in Typescript.  What it needs to do is:
 * 1) find all typescript files in a directory named just 'plugin', and use only
 *    the filenames that end in 'Plugin.ts'.
 * 2) each plugin typescript file will declare and export one class, with its
 *    own unique class name, that contains functions and members that the main
 *    program should be able to reference and call easily. Each plugin file may
 *    import modules that its own functions depend on.
 * 3) build an object that contains all of the functions from all of the plugin
 *    files as member functions, and return that to the main program so that the
 *    main program can call any of those functions it would like to use.
 * 4) the plugin loader should be in its own .ts file.
 * 
 * LLM FUNCTIONS:
 * If you want your method or function to be callable by an LLM, then it must be
 * fully and correctly documented via JSDoc comments including the method or
 * function name, parameter types, and useful descriptions of everything. Also
 * the method or function JSDoc comment must contain a "@llmFunction" tag.  In
 * that case, this plugin loader will generate an LLM compatible tools array
 * object that contains JSON schema necessary to call the functions via the LLM.
 * You can access that by referencing `plugins.tools` from the main program.
 * 
 * Typescript Docs: JSDoc Reference
 * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html
 * 
 * Here is an example of a sample plugin class (samplePlugin.ts), but without the
 * required JSDoc comments (since we can't show JSDoc inside JSDoc!):
 * 
 * class SamplePlugin {
 *   constructor() {
 *     console.log('SamplePlugin loaded.');
 *   }
 *
 *   public add(a: number, b: number): number {
 *     return a + b;
 *   }
 * }
 * export default SamplePlugin;
 * 
 * Then, load the plugins from your main program like this:
 * 
 *   import { PluginLoader } from './plugin/pluginLoader';
 *   // Get the directory of the current script file
 *   const currentDir = path.dirname(__filename);
 *   let pluginDir = process.env.PLUGIN_DIR || 'plugin';
 *   // Load the plugins.
 *   const loader = new PluginLoader(path.join(currentDir, pluginDir));
 *   const plugins = await loader.loadPlugins();
 * 
 *   // Inspect the LLM functions API
 *   console.log(plugins.tools);
 *   // Call a plugin function
 *   plugins.add(1, 2);
 * 
 * @author Yavin Five
 */
export class PluginLoader {
  private pluginDir: string;

  constructor(pluginDir: string) {
    this.pluginDir = pluginDir;
  }

  async loadPlugins(): Promise<any> {
    const plugins: any = {};
    const files = readdirSync(this.pluginDir);

    // tools is function metadata about the exposed plugin functions
    const tools: { type: string; function: FunctionInfo; }[] = [];
    plugins.tools = tools;
    const llmFunctionNames: string[] = [];
    plugins.llmFunctionNames = llmFunctionNames;

    for (const file of files) {
      if (!file.endsWith('Plugin.ts')) continue;
      console.log(`Loading plugin: ${file}`);
      const moduleFilename = path.join(this.pluginDir, file);
      //console.log(`.. from file: ${moduleFilename}`);
      let module;
      try {
        module = await import(moduleFilename);
      } catch (error) {
        console.error(`PluginLoader: Error importing plugin ${file}:`, error);
        continue;
      }
      const pluginClass = module.default;
      if (!pluginClass) {
        console.error(`PluginLoader: No default export found in '${moduleFilename}'`);
        continue;
      }
      //console.log('pluginClass: ' + pluginClass);

      // Create an instance of the plugin class and use it
      const pluginInstance = new pluginClass();

      // Map all plugin functions to be visible to the application.
      Object.getOwnPropertyNames(Object.getPrototypeOf(pluginInstance))
        .filter(prop => prop !== 'constructor')
        .forEach(name => {
          //console.log('name: ' + name);
          //console.log('type: ' + typeof pluginInstance[name]);
          plugins[name] = pluginInstance[name].bind(pluginInstance);
        });

      // Map all plugin non-function class members to be visible to the application.
      Object.getOwnPropertyNames(pluginInstance)
        .filter(prop => prop !== 'constructor' && prop !== 'function')
        .forEach(name => {
          //console.log('name: ' + name);
          //console.log('type: ' + typeof pluginInstance[name]);
          plugins[name] = pluginInstance[name];
        });

      const reader = new JSDocReader([moduleFilename]);
      // JSDocReader will read the plugin's JSDoc comments and modify the
      // tools array to add any LLM functions.
      reader.getJSDocComments(moduleFilename, tools);
      //console.log(JSON.stringify(tools));
    }

    console.log('PluginLoader: Done loading.');
    return plugins;
  }
}

interface FunctionInfo {
  name: string | null;
  description: string;
  parameters: {
    type: "object";
    properties: {};
    required: string[];
  };
}

class JSDocReader {
  private program: ts.Program;

  constructor(private filePaths: string[]) {
    this.program = ts.createProgram(filePaths, {});
  }

  getJSDocComments(filePath: string, tools: { type: string; function: FunctionInfo; }[]) {
    const sourceFile = this.program.getSourceFile(filePath);
    if (!sourceFile) {
      throw new Error(`File ${filePath} not found`);
    }

    let functionInfo: FunctionInfo = {
      name: null,
      description: "",
      parameters: { type: "object", properties: {}, required: [] }
    };

    const visit = (node: ts.Node) => {
      // Uncomment the next line to see a lot of program structure output.
      //console.log(node);
      // Class method and function discovery
      if (ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node) ||
          ts.isJSDocParameterTag(node) && node.name) {
        const symbol = (this.program.getTypeChecker().getSymbolAtLocation(node.name as ts.PropertyName));
        if (symbol) {
          // Discover method or function JSDoc comment block.
          const comments = ts.displayPartsToString(symbol.getDocumentationComment(this.program.getTypeChecker()));
          if (comments && node.name) {
            //console.log(comments);
            functionInfo.description = comments;
            let identifier = node['name'] as ts.Identifier;
            let methodOrFuncName = identifier.escapedText;
            let regularStringName = methodOrFuncName.toString();
            functionInfo.name = regularStringName;
          }

          // Discover argument parameters JSDoc tags, and any return value JSDoc tag
          const jsDocTags: ts.JSDocTag[] = (node as any).jsDoc?.flatMap((doc: { tags: any; }) => doc.tags) ?? [];
          jsDocTags.forEach(tag => {
            if (ts.isJSDocParameterTag(tag)) {
              // Parameter
              const name = tag.name.getText();
              // It's an optional parameter if the name is bracketed.
              const optional = tag.isBracketed;
              const type = tag.typeExpression?.getText().replace(/[{}]/g, '');
              let description = tag.comment?.toString() || '';
              if (optional) {
                description = `${description} Optional argument.`;
                // TODO: Support optional arg with a default value.
              } else {
                functionInfo.parameters.required.push(name);
              }
              if (type && name) {
                // Add this parameter to the tools API's list of parameters for this function.
                const currentProperties = functionInfo.parameters.properties;
                try {
                  const newPropObj = new Object(
                    JSON.parse(`{ "${name}": { "type": "${type}", "description": "${description}"}}`));
                  functionInfo.parameters.properties = Object.assign(currentProperties, newPropObj);
                } catch (error) {
                  console.error(`PluginLoader: Error parsing parameter info for ${name}:`, error);
                }

                // See if it also has the @llmFunction custom tag.
                const tagsArray = tag.parent.tags;
                let llmFunc = false;
                let t: any;
                for (t in tagsArray) {
                  if (tagsArray && tagsArray[t].tagName?.escapedText == 'llmFunction') {
                    llmFunc = true;
                    break;
                  }
                }
                if (!llmFunc) {
                  // We nullify the name so that this function doesn't get
                  // added to the tools array.
                  functionInfo.name = null;
                }
              } else {
                const methodOrFuncName = node.name?.getText();
                console.warn(`${filePath} contains a method or function named '${methodOrFuncName}' `
                  + `that has a JSDoc @param tag for a parameter that either does not declare its type `
                  + `or its name.  Due to this, the method or function will not be properly available `
                  + `to the main program.`);
              }
            } else if (ts.isJSDocReturnTag(tag)) {
              // Return value
              //const type = (tag as any).typeExpression?.getText().replace(/[{}]/g, '');
              const returnTagDescription = tag.comment?.toString() || '';
              const currentDescription = functionInfo.description;
              functionInfo.description = `${currentDescription} Returns ${returnTagDescription}`;
            }
          });

          if (functionInfo.name !== null) {
            tools.push({ "type": "function", "function": functionInfo });
          }

          // Reset storage for the next method or function.
          functionInfo = {
            name: null,
            description: "",
            parameters: { type: "object", properties: {}, required: [] }
          };
        }
      }
      ts.forEachChild(node, visit);
    };
    visit(sourceFile);

    return functionInfo;
  }
}
